local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/danuup16/mnbru/refs/heads/main/mnu"))()
local HttpService = game:GetService("HttpService")

local AutoConfig = {} do
    AutoConfig.FolderName = "DJSTest"
    AutoConfig.ConfigFile = "DJShz.json"
    AutoConfig.Library = nil
    AutoConfig.LastSaveTime = 0
    AutoConfig.IsMonitoring = false
    AutoConfig.Parsers = {
        Toggle = {
            Save = function(idx, option) 
                return { type = "Toggle", idx = idx, value = option.Value } 
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Slider = {
            Save = function(idx, option)
                return { type = "Slider", idx = idx, value = tonumber(option.Value) }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Dropdown = {
            Save = function(idx, option)
                return { type = "Dropdown", idx = idx, value = option.Value, multi = option.Multi }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValue(data.value)
                end
            end,
        },
        Colorpicker = {
            Save = function(idx, option)
                return { type = "Colorpicker", idx = idx, value = option.Value:ToHex(), transparency = option.Transparency }
            end,
            Load = function(idx, data, options)
                if options[idx] then 
                    options[idx]:SetValueRGB(Color3.fromHex(data.value), data.transparency)
                end
            end,
        },
        Input = {
            Save = function(idx, option)
                return { type = "Input", idx = idx, text = option.Value }
            end,
            Load = function(idx, data, options)
                if options[idx] and type(data.text) == "string" then
                    options[idx]:SetValue(data.text)
                end
            end,
        },
    }
    
    function AutoConfig:Initialize(library)
        self.Library = library
        self:CreateFolders()
        wait(2) 
        self:LoadConfig()
        self:StartChangeMonitoring()
    end
    
    function AutoConfig:CreateFolders()
        if not isfolder(self.FolderName) then
            makefolder(self.FolderName)
        end
    end
    
    function AutoConfig:GetFilePath()
        return self.FolderName .. "/" .. self.ConfigFile
    end
    
    function AutoConfig:SaveConfig()
        local data = { objects = {} }
        
        for idx, option in pairs(self.Library.Options) do
            local parser = self.Parsers[option.Type]
            if parser then
                table.insert(data.objects, parser.Save(idx, option))
            end
        end
        
        local success, encoded = pcall(HttpService.JSONEncode, HttpService, data)
        if success then
            writefile(self:GetFilePath(), encoded)
            self.LastSaveTime = tick()
            return true, "Config saved successfully"
        else
            return false, "Failed to encode config data"
        end
    end
    
    function AutoConfig:LoadConfig()
        local filePath = self:GetFilePath()
        
        if not isfile(filePath) then
            return false, "No config file found"
        end
        
        local success, decoded = pcall(HttpService.JSONDecode, HttpService, readfile(filePath))
        if not success then
            return false, "Failed to decode config"
        end
        
        for _, item in pairs(decoded.objects) do
            local parser = self.Parsers[item.type]
            if parser then
                spawn(function()
                    parser.Load(item.idx, item, self.Library.Options)
                end)
            end
        end
        return true, "Config loaded successfully"
    end
    
    function AutoConfig:StartChangeMonitoring()
        if self.IsMonitoring then return end
        self.IsMonitoring = true
        local lastValues = {}
        for idx, option in pairs(self.Library.Options) do
            lastValues[idx] = self:GetOptionValue(option)
        end
        
        spawn(function()
            while self.IsMonitoring do
                wait(0.5)
                
                local hasChanges = false
                for idx, option in pairs(self.Library.Options) do
                    local currentValue = self:GetOptionValue(option)
                    if self:ValuesAreDifferent(lastValues[idx], currentValue) then
                        lastValues[idx] = currentValue
                        hasChanges = true
                    end
                end
                
                if hasChanges then
                    local success, msg = self:SaveConfig()
                    if success then
                    end
                end
            end
        end)
    end
    
    function AutoConfig:GetOptionValue(option)
        if option.Type == "Toggle" then
            return option.Value
        elseif option.Type == "Slider" then
            return option.Value
        elseif option.Type == "Dropdown" then
            return option.Value
        elseif option.Type == "Input" then
            return option.Value
        elseif option.Type == "Colorpicker" then
            return {option.Value:ToHex(), option.Transparency}
        end
        return nil
    end
    
    function AutoConfig:ValuesAreDifferent(oldValue, newValue)
        if type(oldValue) ~= type(newValue) then
            return true
        end
        
        if type(oldValue) == "table" then
            if #oldValue ~= #newValue then return true end
            for i = 1, #oldValue do
                if oldValue[i] ~= newValue[i] then return true end
            end
            return false
        end
        
        return oldValue ~= newValue
    end
    
    function AutoConfig:StopMonitoring()
        self.IsMonitoring = false
    end
    
    function AutoConfig:ManualSave()
        return self:SaveConfig()
    end
    
    function AutoConfig:GetLastSaveTime()
        return self.LastSaveTime
    end
end

local Window = Fluent:CreateWindow({
    Title = "#DJSTEST - Hunty Zombie v.0.1 ",
    SubTitle = "",
    TabWidth = 160,
    Size = UDim2.fromOffset(650, 400),
    Transparency = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.F
})

local Tabs = {
    Info = Window:AddTab({ Title = "Info Script", Icon = "info" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user-cog" }),
    Farm = Window:AddTab({ Title = "Farm", Icon = "zap" })
}

local Options = Fluent.Options

-- Variables for character setup
local defaultWalkSpeed = 16
local defaultJumpPower = 16
local isWalkSpeedActive = false
local currentWalkSpeed = 50

-- Character setup function
local function setupCharacter()
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character.Humanoid
        if not Options.WalkSpeedSlider then
            defaultWalkSpeed = humanoid.WalkSpeed
        end
        if not Options.JumpHeightSlider then
            defaultJumpPower = humanoid.JumpPower
        end
        
        -- Apply walk speed based on toggle state
        if isWalkSpeedActive and Options.WalkSpeedSlider then
            humanoid.WalkSpeed = Options.WalkSpeedSlider.Value or currentWalkSpeed
        else
            humanoid.WalkSpeed = defaultWalkSpeed
        end
        
        if Options.JumpHeightSlider then
            humanoid.JumpPower = Options.JumpHeightSlider.Value or defaultJumpPower
        end
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacter)
if game.Players.LocalPlayer.Character then
    setupCharacter()
end

-- Info Tab
do
    Tabs.Info:AddButton({
        Title = "Discord Server",
        Description = "Discord invite link",
        Callback = function()
            setclipboard("https://discord.gg/uwXYuxj6cF")
        end
    })
    
    Tabs.Info:AddButton({
        Title = "Tiktok",
        Description = "Tiktok profile link",
        Callback = function()
            setclipboard("https://www.tiktok.com/@daanujs_")
        end
    })
end

-- Player Tab
do
    -- Walk Speed Slider
    local WalkSpeedSlider = Tabs.Player:AddSlider("WalkSpeedSlider", {
        Title = "Walk Speed",
        Description = "Control your walking speed",
        Default = 50,
        Min = 16,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            currentWalkSpeed = Value
            -- Only apply if toggle is active
            if isWalkSpeedActive then
                local player = game.Players.LocalPlayer
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    player.Character.Humanoid.WalkSpeed = Value
                end
            end
        end
    })
    
    -- Jump Height
    local JumpHeightSlider = Tabs.Player:AddSlider("JumpHeightSlider", {
        Title = "Jump Height",
        Description = "Control your jumping power",
        Default = defaultJumpPower,
        Min = 0,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid.JumpPower = Value
            end
        end
    })
    
    -- Fly variables and functions
    local flyBodyVelocity = nil
    local flyBodyPosition = nil
    local isFlyActive = false
    local flySpeed = 50
    
    local FlySpeedSlider = Tabs.Player:AddSlider("FlySpeedSlider", {
        Title = "Fly Speed",
        Description = "Control your flying speed",
        Default = flySpeed,
        Min = 10,
        Max = 1000,
        Rounding = 5,
        Callback = function(Value)
            flySpeed = Value
        end
    })
    
    local function enableFly()
        local player = game.Players.LocalPlayer
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return false
        end
        local humanoidRootPart = player.Character.HumanoidRootPart
        flyBodyVelocity = Instance.new("BodyVelocity")
        flyBodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
        flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
        flyBodyVelocity.Parent = humanoidRootPart
        flyBodyPosition = Instance.new("BodyPosition")
        flyBodyPosition.MaxForce = Vector3.new(4000, 4000, 4000)
        flyBodyPosition.Position = humanoidRootPart.Position
        flyBodyPosition.Parent = humanoidRootPart
        return true
    end
    
    local function disableFly()
        if flyBodyVelocity then
            flyBodyVelocity:Destroy()
            flyBodyVelocity = nil
        end
        if flyBodyPosition then
            flyBodyPosition:Destroy()
            flyBodyPosition = nil
        end
    end
    
    local function updateFlyMovement()
        local player = game.Players.LocalPlayer
        local camera = workspace.CurrentCamera
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        local humanoidRootPart = player.Character.HumanoidRootPart
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not flyBodyVelocity or not flyBodyPosition or not humanoid then
            return
        end
        local moveVector = humanoid.MoveDirection
        local velocity = Vector3.new(0, 0, 0)
        if moveVector.Magnitude > 0 then
            local cameraDirection = camera.CFrame.LookVector
            local flatDirection = Vector3.new(cameraDirection.X, 0, cameraDirection.Z).Unit
            velocity = flatDirection * moveVector.Magnitude * flySpeed
        end
        local userInputService = game:GetService("UserInputService")
        if userInputService:IsKeyDown(Enum.KeyCode.Space) then
            velocity = velocity + Vector3.new(0, flySpeed, 0)
        end
        if userInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
            velocity = velocity + Vector3.new(0, -flySpeed, 0)
        end
        flyBodyVelocity.Velocity = velocity
        if velocity.Magnitude == 0 then
            flyBodyPosition.Position = humanoidRootPart.Position
        else
            flyBodyPosition.Position = humanoidRootPart.Position + velocity * 0.1
        end
    end
     -- Walk Speed Toggle
    local WalkSpeedToggle = Tabs.Player:AddToggle("WalkSpeedToggle", {
        Title = "Walk Speed",
        Description = "Enable custom walk speed",
        Default = false,
        Callback = function(Value)
            isWalkSpeedActive = Value
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                if Value then
                    player.Character.Humanoid.WalkSpeed = currentWalkSpeed
                else
                    player.Character.Humanoid.WalkSpeed = defaultWalkSpeed
                end
            end
        end
    })
    local flyToggle = Tabs.Player:AddToggle("FlyToggle", {
        Title = "Fly",
        Description = "Enable flying mode",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isFlyActive then
                    if enableFly() then
                        isFlyActive = true
                        spawn(function()
                            while isFlyActive do
                                updateFlyMovement()
                                game:GetService("RunService").Heartbeat:Wait()
                            end
                        end)
                    end
                end
            else
                if isFlyActive then
                    isFlyActive = false
                    disableFly()
                end
            end
        end
    })
    
    -- Infinite Jump
    local infiniteJumpConnection = nil
    local isInfiniteJumpActive = false
    
    local function enableInfiniteJump()
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
        end
        infiniteJumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("Humanoid") then
                player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end)
    end
    
    local function disableInfiniteJump()
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
            infiniteJumpConnection = nil
        end
    end
    
    local infiniteJump = Tabs.Player:AddToggle("InfiniteJump", {
        Title = "Infinite Jump",
        Description = "Jump infinitely without touching ground",
        Default = false,
        Callback = function(Value)
            if Value then
                if not isInfiniteJumpActive then
                    enableInfiniteJump()
                    isInfiniteJumpActive = true
                end
            else
                if isInfiniteJumpActive then
                    disableInfiniteJump()
                    isInfiniteJumpActive = false
                end
            end
        end
    })
    
    -- No Clip
    local isNoclipActive = false
    local noclipConnection = nil
    local RunService = game:GetService("RunService")
    
    local function enableNoclip()
        local player = game.Players.LocalPlayer
        if not player.Character then
            return false
        end
        if noclipConnection then
            noclipConnection:Disconnect()
        end
        noclipConnection = RunService.Stepped:Connect(function()
            if not isNoclipActive then
                noclipConnection:Disconnect()
                return
            end
            local character = player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end)
        
        return true
    end
    
    local function disableNoclip()
        local player = game.Players.LocalPlayer
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    if part.Name == "Head" or part.Name:find("Torso") or part.Name:find("Arm") or part.Name:find("Leg") then
                        part.CanCollide = false
                    else
                        part.CanCollide = true
                    end
                end
            end
            if player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CanCollide = false
            end
        end
    end
    
    local function setupCharacterNoclip()
        local player = game.Players.LocalPlayer
        if player.Character and isNoclipActive then
            wait(0.5)
            enableNoclip()
        end
    end
    
    game.Players.LocalPlayer.CharacterAdded:Connect(setupCharacterNoclip)
    
    local noclipToggle = Tabs.Player:AddToggle("NoClip", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(Value)
            isNoclipActive = Value
            if Value then
                enableNoclip()
            else
                disableNoclip()
            end
        end
    })
    local copycords = Tabs.Player:AddButton({
        Title = "Copy Coords",
        Description = "copy coords",
        Callback = function()
                    local player = game.Players.LocalPlayer
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local pos = player.Character.HumanoidRootPart.CFrame
            -- Format ke string
            local coordsString = string.format(
                "CFrame.new(%.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f, %.6f)",
                pos:GetComponents()
            )
            setclipboard(coordsString)
            Fluent:Notify({
                Title = "Copied to clipboard",
                Content = "copy coords!",
                Duration = 2
            })
        end
        end
    })
    local playerTab = Tabs.Player
    local player = game.Players.LocalPlayer
    local isGodMode = false
    local healthConnection = nil

    -- hapus FallDamage script kalau ada
    local function removeFallDamageScript(char)
        local fallScript = char:FindFirstChild("FallDamage")
        if fallScript then
            fallScript:Destroy()
            warn("FallDamage script dihapus!")
        end
    end

    -- loop disable touch damage
    local function disableTouchLoop()
        while isGodMode do
            task.wait(0.3)
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local hrp = char.HumanoidRootPart
                local parts = workspace:GetPartBoundsInRadius(hrp.Position, 20)
                for _, part in ipairs(parts) do
                    if part:IsA("BasePart") then
                        part.CanTouch = false
                    end
                end
            end
        end
    end

    -- aktifkan God Mode
    local function enableGodMode()
        local char = player.Character or player.CharacterAdded:Wait()
        local humanoid = char:WaitForChild("Humanoid")

        -- hapus FallDamage script
        removeFallDamageScript(char)

        -- auto full HP
        humanoid.Health = humanoid.MaxHealth
        healthConnection = humanoid.HealthChanged:Connect(function()
            if isGodMode and humanoid.Health < humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end)

        -- disable touch damage
        task.spawn(disableTouchLoop)
    end

    -- nonaktifkan God Mode
    local function disableGodMode()
        if healthConnection then
            healthConnection:Disconnect()
            healthConnection = nil
        end
    end

    -- Toggle UI
    playerTab:AddToggle("GodMode", {
        Title = "God Mode / No Damage",
        Description = "Imun dari fall damage, touch damage, dan senjata",
        Default = false,
        Callback = function(Value)
            isGodMode = Value
            if Value then
                enableGodMode()
            else
                disableGodMode()
            end
        end
    })
    player.CharacterAdded:Connect(function(char)
        task.wait(1)
        if isGodMode then
            enableGodMode()
        else
            disableGodMode()
        end
    end)
end
-- Farm Tab
do
    -- Auto Tool Activate Variables
    local isAutoClickActive = false
    local autoClickConnection = nil
    local clickDelay = 0.1
    local RunService = game:GetService("RunService")
    
    -- Auto Teleport NPC Variables
    local isAutoTeleportActive = false
    local autoTeleportConnection = nil
    local teleportRange = 100
    local teleportDelay = 0.5
    local lastTeleportTime = 0
    
    -- Farm 1 Variables (CFrame-based Detection)
    local isFarm1Active = false
    local farm1Connection = nil
    local farm1Delay = 1
    local lastFarm1Time = 0
    local visitedPositions = {} -- Changed from visitedDoors to visitedPositions
    local lastDoorRefreshTime = 0
    local doorRefreshInterval = 5
    local positionTolerance = 5 -- Distance tolerance for considering positions the same
    
    -- Click Delay Slider
    local ClickDelaySlider = Tabs.Farm:AddSlider("ClickDelaySlider", {
        Title = "Click Delay",
        Description = "Set delay between tool activations (seconds)",
        Default = 0.1,
        Min = 0.01,
        Max = 5,
        Rounding = 2,
        Callback = function(Value)
            clickDelay = Value
        end
    })
    
    -- Teleport Range Slider
    local TeleportRangeSlider = Tabs.Farm:AddSlider("TeleportRangeSlider", {
        Title = "Teleport Range",
        Description = "Set range to search for zombie parts",
        Default = 100,
        Min = 10,
        Max = 500,
        Rounding = 1,
        Callback = function(Value)
            teleportRange = Value
        end
    })
    
    -- Teleport Delay Slider
    local TeleportDelaySlider = Tabs.Farm:AddSlider("TeleportDelaySlider", {
        Title = "Teleport Delay",
        Description = "Set delay between teleports (seconds)",
        Default = 0.5,
        Min = 0.1,
        Max = 5,
        Rounding = 1,
        Callback = function(Value)
            teleportDelay = Value
        end
    })
    
    -- Farm 1 Delay Slider
    local Farm1DelaySlider = Tabs.Farm:AddSlider("Farm1DelaySlider", {
        Title = "Farm 1 Delay",
        Description = "Set delay between door teleports (seconds)",
        Default = 1,
        Min = 0.5,
        Max = 10,
        Rounding = 1,
        Callback = function(Value)
            farm1Delay = Value
        end
    })
    
    -- Auto Tool Activate Function
    local function performToolActivate()
        local player = game.Players.LocalPlayer
        
        if player.Character then
            local tool = player.Character:FindFirstChildOfClass("Tool")
            if tool then
                tool:Activate()
            end
        end
    end
    
    -- Find Zombie Parts in Camera
    local function findZombieInCamera()
        local player = game.Players.LocalPlayer
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return nil
        end
        
        local playerPosition = player.Character.HumanoidRootPart.Position
        local closestZombie = nil
        local closestDistance = math.huge
        
        -- Search in workspace > Camera for zombie parts
        local camera = workspace:FindFirstChild("Camera")
        if camera then
            for _, obj in pairs(camera:GetChildren()) do
                if obj:IsA("BasePart") then
                    local entityTeam = obj:GetAttribute("EntityTeam")
                    
                    if entityTeam and entityTeam == "Zombie" then
                        pcall(function()
                            local distance = (obj.Position - playerPosition).Magnitude
                            if distance <= teleportRange and distance < closestDistance then
                                closestDistance = distance
                                closestZombie = obj
                            end
                        end)
                    end
                end
            end
        end
        
        return closestZombie
    end
    
    -- Auto Teleport to NPC Function
    local function performAutoTeleportNPC()
        local currentTime = tick()
        if currentTime - lastTeleportTime < teleportDelay then
            return
        end
        
        local player = game.Players.LocalPlayer
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        local zombiePart = findZombieInCamera()
        if not zombiePart then
            return
        end
        
        -- Get zombie's current CFrame
        local zombieCFrame = zombiePart.CFrame
        local entityID = zombiePart:GetAttribute("EntityID")
        
        print("Teleporting to zombie ID:", entityID, "at CFrame:", zombieCFrame)
        
        -- Teleport player to zombie location
        pcall(function()
            player.Character.HumanoidRootPart.CFrame = zombieCFrame
            print("Successfully teleported to zombie location")
        end)
        
        lastTeleportTime = currentTime
    end
    
    -- Function to create position key from CFrame
    local function createPositionKey(cframe)
        local x, y, z = cframe.X, cframe.Y, cframe.Z
        -- Round to nearest integer to handle floating point precision
        return math.floor(x + 0.5) .. "," .. math.floor(y + 0.5) .. "," .. math.floor(z + 0.5)
    end
    
    -- Function to check if position already visited
    local function isPositionVisited(cframe)
        local newKey = createPositionKey(cframe)
        
        -- Check if exact position already visited
        if visitedPositions[newKey] then
            return true
        end
        
        -- Check if any nearby position was visited (within tolerance)
        for visitedKey, _ in pairs(visitedPositions) do
            local coords = {}
            for coord in visitedKey:gmatch("([^,]+)") do
                table.insert(coords, tonumber(coord))
            end
            
            if #coords == 3 then
                local visitedPos = Vector3.new(coords[1], coords[2], coords[3])
                local currentPos = Vector3.new(cframe.X, cframe.Y, cframe.Z)
                local distance = (visitedPos - currentPos).Magnitude
                
                if distance <= positionTolerance then
                    return true
                end
            end
        end
        
        return false
    end
    
    -- Find All HallwayDoor Root Parts and Sort by Distance (CFrame-based)
    local function findAndSortHallwayDoors()
        local doorRoots = {}
        local player = game.Players.LocalPlayer
        
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return doorRoots
        end
        
        local playerPosition = player.Character.HumanoidRootPart.Position
        
        -- Search specifically in workspace > School > Doors
        local school = workspace:FindFirstChild("School")
        if school then
            local doors = school:FindFirstChild("Doors")
            if doors then
                local doorCount = 1
                for _, obj in pairs(doors:GetChildren()) do
                    if obj.Name:match("HallwayDoor") and obj:IsA("Model") then
                        local root = obj:FindFirstChild("Root")
                        if root and root:IsA("BasePart") then
                            local distance = (root.Position - playerPosition).Magnitude
                            local positionKey = createPositionKey(root.CFrame)
                            local visited = isPositionVisited(root.CFrame)
                            
                            table.insert(doorRoots, {
                                name = obj.Name .. "_" .. doorCount, -- Add unique suffix for display
                                root = root,
                                position = root.Position,
                                cframe = root.CFrame,
                                distance = distance,
                                positionKey = positionKey,
                                visited = visited
                            })
                            
                            print("Found HallwayDoor #" .. doorCount .. ":", obj.Name, 
                                  "at position:", math.floor(root.Position.X), math.floor(root.Position.Y), math.floor(root.Position.Z), 
                                  "distance:", math.floor(distance), 
                                  "visited:", visited and "YES" or "NO")
                            
                            doorCount = doorCount + 1
                        end
                    end
                end
            else
                print("Doors folder not found in School")
            end
        else
            print("School folder not found in workspace")
        end
        
        -- Sort doors by distance (closest first)
        table.sort(doorRoots, function(a, b)
            return a.distance < b.distance
        end)
        
        print("Total HallwayDoors found and sorted:", #doorRoots)
        
        -- Print sorted order with better debugging
        for i, door in ipairs(doorRoots) do
            local visitedStatus = door.visited and "VISITED" or "NOT VISITED"
            print("Door " .. i .. ":", door.name, "distance:", math.floor(door.distance), 
                  "pos:", door.positionKey, visitedStatus)
        end
        
        return doorRoots
    end
    
    -- Farm 1 Teleport Function (Keep Toggle ON, Stop Function Only)
    local function performFarm1Teleport()
        local currentTime = tick()
        if currentTime - lastFarm1Time < farm1Delay then
            return
        end
        
        local player = game.Players.LocalPlayer
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        -- Get all doors with updated visit status
        local allDoors = findAndSortHallwayDoors()
        
        if #allDoors == 0 then
            print("No doors found!")
            return
        end
        
        -- Count visited doors properly
        local visitedCount = 0
        local unvisitedDoors = {}
        
        for _, door in ipairs(allDoors) do
            if door.visited then
                visitedCount = visitedCount + 1
            else
                table.insert(unvisitedDoors, door)
            end
        end
        if visitedCount >= #allDoors then
            if farm1Connection then
                farm1Connection:Disconnect()
                farm1Connection = nil
                print("Farm 1 processing stopped, but toggle stays ON")
            end
            wait(1)
            if not isAutoTeleportActive and Options.AutoTeleportToggle then
                Options.AutoTeleportToggle:SetValue(true)
                print("Auto Teleport NPC enabled automatically")
            end
            if not isAutoClickActive and Options.AutoClickToggle then
                Options.AutoClickToggle:SetValue(true) 
                print("Auto Tool Activate enabled automatically")
            end
            Fluent:Notify({
                Title = "Farm 1 Complete - Auto Transition",
                Content = "All " .. #allDoors .. " doors visited! Farm 1 toggle stays ON. Auto farming enabled.",
                Duration = 5
            })
            return
        end
        local targetDoor = unvisitedDoors[1]
        if not targetDoor then
            return
        end
        local doorIndex = 1
        for i, door in ipairs(allDoors) do
            if door.positionKey == targetDoor.positionKey then
                doorIndex = i
                break
            end
        end
        pcall(function()
            player.Character.HumanoidRootPart.CFrame = targetDoor.cframe
            visitedPositions[targetDoor.positionKey] = true
            local newVisitedCount = visitedCount + 1
            Fluent:Notify({
                Title = "Farm 1 Progress",
                Content = "Door " .. doorIndex .. "/" .. #allDoors .. " completed. " .. (#allDoors - newVisitedCount) .. " remaining.",
                Duration = 2
            })
        end)
        lastFarm1Time = currentTime
    end
    local AutoClickToggle = Tabs.Farm:AddToggle("AutoClickToggle", {
        Title = "Auto Tool Activate",
        Description = "Automatically activate equipped tool",
        Default = false,
        Callback = function(Value)
            isAutoClickActive = Value
            
            if Value then
                if autoClickConnection then
                    autoClickConnection:Disconnect()
                    autoClickConnection = nil
                end
                
                local lastActivateTime = 0
                autoClickConnection = RunService.Heartbeat:Connect(function()
                    if not isAutoClickActive then
                        if autoClickConnection then
                            autoClickConnection:Disconnect()
                            autoClickConnection = nil
                        end
                        return
                    end
                    
                    local currentTime = tick()
                    if currentTime - lastActivateTime >= clickDelay then
                        performToolActivate()
                        lastActivateTime = currentTime
                    end
                end)
            else
                isAutoClickActive = false
                if autoClickConnection then
                    autoClickConnection:Disconnect()
                    autoClickConnection = nil
                end
            end
        end
    })
    
    -- Farm 1 Toggle (Keep Toggle ON when complete)
    local Farm1Toggle = Tabs.Farm:AddToggle("Farm1Toggle", {
        Title = "Farm 1 - Door Teleport (Auto)",
        Description = "Visit all doors, then auto-enable farming (toggle stays ON when done)",
        Default = false,
        Callback = function(Value)
            print("Farm 1 (Keep Toggle ON) toggled:", Value)
            isFarm1Active = Value
            
            if Value then
                print("Starting Farm 1 - Door Teleport with Auto Transition")
                
                -- Reset all state for new session
                visitedPositions = {}
                lastDoorRefreshTime = 0
                
                if farm1Connection then
                    farm1Connection:Disconnect()
                    farm1Connection = nil
                end
                
                farm1Connection = RunService.Heartbeat:Connect(function()
                    if not isFarm1Active then
                        if farm1Connection then
                            farm1Connection:Disconnect()
                            farm1Connection = nil
                        end
                        return
                    end
                    
                    performFarm1Teleport()
                end)
                
                print("Farm 1 (Keep Toggle ON) connection established")
                
                Fluent:Notify({
                    Title = "Farm 1 Started",
                    Content = "Will auto-enable zombie farming after visiting all doors! Toggle will stay ON when complete.",
                    Duration = 3
                })
            else
                print("Stopping Farm 1")
                isFarm1Active = false
                if farm1Connection then
                    farm1Connection:Disconnect()
                    farm1Connection = nil
                    Options.AutoTeleportToggle:SetValue(false)
                    Options.AutoClickToggle:SetValue(false)
                    print("Farm 1 connection disconnected")
                end
                
                -- Reset state when manually turned off
                visitedPositions = {}
                lastDoorRefreshTime = 0
            end
        end
    })
    
    -- Auto Teleport NPC Toggle
    local AutoTeleportToggle = Tabs.Farm:AddToggle("AutoTeleportToggle", {
        Title = "Auto Teleport NPC",
        Description = "Automatically teleport to nearest zombie part",
        Default = false,
        Callback = function(Value)
            print("Auto Teleport NPC toggled:", Value)
            isAutoTeleportActive = Value
            
            if Value then
                print("Starting auto teleport to zombie NPCs")
                
                if autoTeleportConnection then
                    autoTeleportConnection:Disconnect()
                    autoTeleportConnection = nil
                end
                
                autoTeleportConnection = RunService.Heartbeat:Connect(function()
                    if not isAutoTeleportActive then
                        if autoTeleportConnection then
                            autoTeleportConnection:Disconnect()
                            autoTeleportConnection = nil
                        end
                        return
                    end
                    
                    performAutoTeleportNPC()
                end)
                
                print("Auto teleport connection established")
            else
                print("Stopping auto teleport")
                isAutoTeleportActive = false
                if autoTeleportConnection then
                    autoTeleportConnection:Disconnect()
                    autoTeleportConnection = nil
                    print("Auto teleport connection disconnected")
                end
            end
        end
    })
end
Window:SelectTab(1)
AutoConfig:Initialize(Fluent)
